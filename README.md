# midterm anan 1660706688

// write by anan grammar check by Grammarly (not generated by AI)

## file structure
1. part 1 - 8: main.ts -> .ts
2. part 9: index.html -> .html and .js

## Part 1: Classes and Object-Oriented Programming
I start by creating attributes and methods that match the requirements. Then, I create a static attribute and method that will update the total number of products when a new product is made.

## Part 2: Inheritance and Polymorphism
Create a class that extends the `Product` class and uses `super` in the constructor to replicate how the product constructor works. Moreover, add products that use discount rates to find the final price. The final cost can be calculated by \(1 - \text{discount rate}\). Both the product and the discounted product are tested and printed out to the console.

## Part 3: Type Annotations and Interfaces 
The `Customer` interface stores an array of products. It includes the customer's name and email, along with a list of orders. The number of orders can be calculated using the built-in method to find the array's length. I create `getCustomerInfo` by filtering the class to the customer and using the customer method to return customer information.

## Part 4: Generics
The inventory implementation using generics allows any type that extends the `Product` class to use this class. It utilizes `push` to add more items and returns an array of items (products) when the `listItems` method is called.

## Part 5: Functions and Higher-Order Functions
The `createPriceMultiplier` function creates a function that accepts a product and returns the final price after being affected by the multiplier from the higher-order function. This generates a function that applies the same multiplier every time it is called.

## Part 6: Asynchronous Programming
I created an async function with a random fail rate. If the fail rate exceeds 80%, it will reject the promise and log the error to the console. Conversely, if the fail rate is under 80%, it will return the promised product, which I print out later using another function. All of this works with a 200ms timeout to replicate how asynchronous behavior works in real life.

## Part 7: Array Methods
I generated an array of products by pushing products to the array and using various array methods: `filter`, `map`, and `reduce`, while storing the results in variables. I followed the standard syntax; there is nothing particularly noteworthy here.

## Part 8: Error Handling
I used the same concept as in the async function to create this part. There is a 20% chance of failure. If it fails, I pass through invalid JSON; otherwise, I pass valid JSON.

## Part 9: jQuery DOM Manipulation
All content in this part is stored in `index.html` using jQuery and JavaScript. I didn't use TypeScript here due to the complicated process of compiling a TypeScript file. I created a form and a table as the main structure. Then, I applied jQuery to start when the document is ready/rendered, creating an event listener for the click event. This listener parses the data from the form, creates a `<tr>` tag, and adds it to the table. Finally, I clear all the values from the form to restart the input process.
